# Асинхронный блог на FastAPI + Postgresql + Celery + Redis + RabbitMQ + Flower.

Этот проект был сделан в качесте ознакомлением с популярными инструментами. Для начала рассмотрим используемый стэк в приложения.

* FastAPI
* Postgresql
* Redis
* Celery
* RabbitMQ
* Flower
* PyTest
* Docker

# Работа с приложением.

## Подготовка к обычному запуску приложения.

Для начала клонируем весь репозиторий.

`git clone https://github.com/Keni13-coder/Projects.git`

Перейдите в News_Fastapi.

`cd ../Projects/News_Fastapi`

Создайте вертуального среду.

`python -m venv venv`

Перейдите в виртуальную среду.

`venv\Scripts\activate.ps1`

Утсановите зависимости.

`pip install -r requirements.txt`

Для дальнейшей подготовке перейдите в корнивую рабочий каталог "my_blog".

`cd my_blog`

Созадайте файл .env в подкаталоге __core__. Определите следующие переменные:
* MY_MAIL_USERNAME = ваш email (ипользуеться в качестве имени)
* MY_MAIL_PASSWORD = STMP пароль (посмотрите как получить дынный пароль для внешнего подключения)
* MY_MAIL_FROM = ваш email
* 
* DB_HOST=localhost
* DB_PORT=5432
* DB_NAME= имя базы данных для работы (должна уже быть создана) 
* DB_USER=postgres
* DB_PASS= ваш пароль
* 
* 
* SECRET_KEY= сгенерируйте для большей безопастности (секретная строка)
* 
* LOG_LEVEL=info
* LOG_FORMAT=JSON
* LOG_DIR=./logs/
* LOG_FILENAME=app.log
* 
 Должены быть зараннее запущен
* REDIS_HOST=localhost
* REDIS_PORT=6379
* 
* Должены быть зараннее запущен
* RABBITMQ_DEFAULT_USER= ваше имя 
* RABBITMQ_DEFAULT_PASS= ваш пароль
* RABBITMQ_NODE_PORT=5672
* RABBITMQ_DEFAULT_VHOST=/
* HOST_NAME_RABBIT=localhost
* 
* MODE=DEV
* 
* MEDIA=./media

Совершенно не важно как вы запустили Redis и RabbitMQ, главное это соответсвие небходимого для подключения переменных с данными.

Для выполнения команд перейдите в рабочую директорию my_blog.

Команды:

1. `alembic upgrade head` - создаёт таблици обновляя их до последней версии миграций

2. `celery -A background_celery.app_celery:celery worker --loglevel=INFO --logfile=./logs/celery.log` - запуск celery в режиме worker с логированием

3. `celery -A background_celery.app_celery:celery flower` - запуск flower порт по умолчанию "5555"

4. `uvicorn run:app` - обычный запуск приложения

Если есть жилание поиграться с отладчиком перейдите в файл run, находящийся в корнивой директории. Чтобы включить режим отладки (debug) передайте в функцию create_app(True).

`uvicorn run:app --reload` - для удобства добавляем перезагрузку

### Запуск приложения через контейнер Docker.

Для начала клонируем весь репозиторий.

`git clone https://github.com/Keni13-coder/Projects.git`

Перейдите в корнивую рабочию директорию проекта

`cd ../Projects/News_Fastapi/my_blog`

Создайте файл .env-non-dev в подкаталоге __core__. Определите следующие переменные:

* MY_MAIL_USERNAME = ваш email (ипользуеться в качестве имени)
* MY_MAIL_PASSWORD = STMP пароль (посмотрите как получить дынный пароль для внешнего подключения)
* MY_MAIL_FROM = ваш email
* 
* DB_HOST=db
* DB_PORT=1212
* DB_NAME=имя базы данных которя будет создана
* DB_USER= имя пользователя
* DB_PASS= пароль пользователя
* 
* Для подключения используйте созданные вами данные
* POSTGRES_DB= DB_NAME
* POSTGRES_USER= DB_USER
* POSTGRES_PASSWORD= DB_PASS
* 
* 
* SECRET_KEY= сгенерируйте для большей безопастности (секретная строка)
* 
* LOG_LEVEL=info
* LOG_FORMAT=JSON
* LOG_DIR=./logs/
* LOG_FILENAME=app.log
* 
* REDIS_HOST=redis
* REDIS_PORT=6374
* 
* 
* RABBITMQ_DEFAULT_USER= ваше имя
* RABBITMQ_DEFAULT_PASS= ваш пароль
* RABBITMQ_NODE_PORT=5673
* RABBITMQ_DEFAULT_VHOST=/
* HOST_NAME_RABBIT=rabbitmq
* 
* MODE=START
* 
* MEDIA=./media

Перед запуском контейнера обратите внимание на файл docker-compose.yml находящийся в корневой папке приложения. В нем вы можите настроить порты если возникнут перекрытие. Так же не забывайте при изменении в данной файле поменять их в .env-non-dev

### Поднимаем контейнер.
Создание и поднятие контейнера docker:

`docker-compose up --build`

### Как устроена работа приложения.

Проект построен на принципе Union Architecture и имеет следующие слои:

1. Entity data base
2. Repository
3. Unit of Work
4. Services
5. EndPoint

Где номер один являеться центром, а номер пять началом. Так же можно выделить отдельно созданные удобста, что не входят в слои, но на прямую работает из сервисов. Это задачи celery, для задач были созданые отдельные настройки и классы задач.

В каталоге __background_celery__ возможна тчательнон изучения при возникновении вопросов.

1. Entity data base обусловленна представленнием работы с базой данных. Там будут описаны основные методы взаимодействий, наследуеться от абстрактного класса

2. Repository, выходит из определения обращений к базе данных наследую класс взаимодействия с базой данных. Так же на этом слое присутствует реализация кеширования самых частых запросов. Кеш храниться в опертивной памяти, для работы с ним выбран Redis. Работает в асинхронном формате. Для правильной работы приложения была переписана настройка для кодирования и декодирования.

В каталоке __db__/__utils__, найдите файл __cache_builder.py__. В данном файле будут надстройки касаемые кеширования.

3. Unit of Work, отвечает за создание сессии, взаимодействия с репозиториями. Так же управляет транзакцией, а если быть точнее запрос будет удачным если все входящие запросы в транзакции не вызовет ошибок. В случае ошибки производиться rollback. Реализовано через контекст менеджера

В каталоке __db__/__utils__, найдите файл __uow_class.py__. В данном файле реализован класс отвечающий за данную логику.

4. Services, основная логика по обработке данных от клиента и подготовке к работе с базой данных. Для сервисов были созданы классы Worker. Данные классы являються помощьниками разделенными по логиике взаимойдествия. Например __HashePasswordWorker__ будут описаны методы исключительно для всевозможной работы с паролем. Так же свервисы запускают задачи celery.

5. EndPoint, построенные http запросы по маршрутам. Для создание конечных точек используеться FastAPI. Так же стоит обратить внимания на зависимости переданные в данные точки. В конечных точках определяються cookie, которые помогают в дальнейшем взаимодействие с приложением.

Все маршруты прописанные для приложения распределены по их ролям, для просмотра перейдите в каталок __apps__